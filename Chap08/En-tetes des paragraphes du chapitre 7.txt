Starting page :

8.0	Vue d'ensemble du chapitre							p.351
8.1	Les instructions de l'assembleur						p.351
8.2	Le compteur d'emplacement							p.353
8.3	Symboles									p.354
8.4	Constantes littérales								p.356
8.4.1	Constantes entières								p.356
8.4.2	Constantes chaînes								p.357
8.4.3	Constantes réelles								p.357
8.4.4	Constantes textuelles								p.358
8.5	Déclarer des constantes manifestes à l'aide des constantes symboliques		p.358
8.6	Directives du processeur							p.360
8.7	Procédures									p.361
8.8	Segments									p.363
8.8.1	Les noms des segments								p.364
8.8.2	Ordre de chargement des segments						p.365
8.8.3	Opérandes de segment								p.365
8.8.3.1	Le type ALIGN									p.365
8.8.3.2 Le type COMBINE									p.369
8.8.4	Le type CLASS									p.371
8.8.5	L'opérande read-only								p.372
8.8.6	Les options USE16, USE32 et FLAT						p.372
8.8.7	Définitions typiques des segments						p.373
8.8.8	Pourquoi contrôler l'ordre de chargement					p.373
8.8.9	Préfixes de segment								p.374
8.8.10	Contrôler les segments à l'aide de la directive ASSUME				p.374
8.8.11	Combiner les segments : La directive GROUP					p.377
8.8.12	Pourquoi se tracasser avec les segments ?					p.380
8.9	La directive END								p.381
8.10	Variables									p.381
8.11	Types des identificateurs								p.382
8.11.1	Comment attribuer un type particulier à un identificateur			p.382
8.11.2	Valeurs des identificateurs							p.383
8.11.3	Conflits de type								p.383
8.12	Expressions d'adresse								p.384
8.12.1	Types de symboles et modes d'adressage						p.385
8.12.2	Opérateurs logiques et arithmétiques						p.385
8.12.3	Coercition									p.387
8.12.4	Opérateurs de type								p.389
8.12.5	Précédence des opérateurs							p.394
8.13	Assemblage conditionnel								p.396
8.13.1	Directive IF									p.397
8.13.2	Directive IFE									p.397
8.13.3	IFDEF et IFNDEF									p.397
8.13.4	IFB, IFNB									p.398
8.13.5	IFIDN, IFDIF, IFIDNI et IFDIFI							p.398
8.14	Macros										p.398
8.14.1	Macros procédurelles								p.399
8.14.2	Les macros par rapport aux procédures 80x86					p.402
8.14.3	La directive LOCAL								p.404
8.14.4	La directive EXITM								p.405
8.14.5	Expansion des paramètres d'une macro et opérateurs de macro			p.405
8.14.6	Une macro échantillon pour implémenter des boucles FOR				p.408
8.14.7	Fonctions macro									p.412
8.14.8	Macros prédéfinies, fonctionnelles et symboles					p.413
8.14.9	Macros Contra Constantes symboliques						p.417
8.14.10	Macros : les pour et les contre							p.417
8.15	Opérations répétitives								p.418
8.16	Les macros itératives FOR et FORC						p.419
8.17	La macro WHILE									p.420
8.18	Paramètres de macro								p.421
8.19	Contrôle du listing								p.422
8.19.1	Les directives ECHO et %OUT							p.422
8.19.2	La directive TITLE								p.422
8.19.3	La directive SUBTTL								p.422
8.19.4	La directive PAGE								p.422
8.19.5	Les directives .LIST, .NOLIST et XLIST						p.423
8.19.6	Autres directives de listing							p.423
8.20	Gérer de larges programmes							p.423
8.20.1	La directive INCLUDE								p.424
8.20.2	Les directives PUBLIC, EXTERN et EXTRN						p.425
8.20.3	La directive EXTERNDEF								p.426
8.21	Make File									p.427
8.22	Exemples de programmes								p.430
8.22.1	EX8.MAK										p.430
8.22.2	Matrix.A									p.430
8.22.3	EX8A.ASM									p.431
8.22.4 	GETI.ASM									p.440
8.22.5	GetArray.ASM									p.442
8.22.6	XProduct.ASM									p.444
8.23	Exercices de laboratoire							p.446
8.23.1	Procédures near et far								p.446
8.23.2	Exercices d'alignement des données						p.447
8.23.3	Exercice sur les constantes symboliques (equates)				p.448
8.23.4	Exercice avec IFDEF								p.449
8.23.5	Exercices sur un fichier Make File						p.450
8.24	Projets de programmation							p.452
8.25	Résumé										p.452
8.26	Questions									P.455
